---
title: 명령어
description: 명령어
date: 2025-08-23
tags: [computer, cs]
series: CS
published: true
---

프로그래밍 언어는 컴퓨터가 바로 이해할 수 없다. 컴퓨터는 명령어를 이해한다.

소스 코드는 실행되기 전 명령어 + 데이터로 변환되어 실행된다.

- 소스 코드(고급 언어): 사람이 이해하기 편한 언어
- 명령어 + 데이터(저급 언어) : 컴퓨터가 이해하기 쉬운 언어

<aside>
📌 즉, 고급 언어로 작성된 소스 코드는 내부적으로 저급 언어로 구성된 명령어와 데이터로 변환된다.

</aside>

### 저급언어

- 기계어(macine code) - 가장 근원적인 언어로 16진수로 표현되는데 이걸 이진수로 표현하면 컴퓨터가 직접 이해할 수 있는 언어로 변환된다.
- 어셈블리어(assembly language) - 기계어를 사람이 좀 더 읽기 쉽게 만든 언어

<aside>
📌 소프트웨어나 CPU의 종류에 따라 생김새가 달라질 수 있다.

</aside>

## 고급 언어에서 저급 언어로 변환되는 대표적 방식

- 컴파일
- 인터프리트

### 컴파일

- 소스 코드 전체가 **컴파일러**에 의해 검사, **목적 코드(Object code)**로 변환
- C/C++, Rust

ex) **gcc**, clang, vscode…

### 인터프리트

- 소스 코드 한 줄 씩 인터프리터에 의해 검사, 목적 코드로 변환
- Python, JavaScript

<aside>
📌 소스 코드가 저급 언어로 변환되는 대표적인 방식일 뿐 완벽하게 하나의 방식으로만 되지 않고 다양하게 사용 될 수 있다.

</aside>

### 명령어가 컴파일 되는 형태

[이 곳](https://godbolt.org/)에서 확인할 수 있다.

## 명령어 구조

명령어는 프로그램을 이루는 두 정보로 이루어져 있다. (0과 1로 이루어짐)

- 명령어: 컴퓨터를 동작시키는 실질적인 정보
- 데이터: 명령어의 대상 (재료)
- 명령의 대상 + 명령의 동작

![command](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/cs/command/command.webp)

| 더해라    | 100과                | 120을                   |
| --------- | -------------------- | ----------------------- |
| 빼라      | 메모리 21번지의 값과 | 메모리 27번지 속의 값을 |
| 저장해라  | 무엇을               | 메모리 129번지에        |
| 연산 코드 | 오퍼랜드             | 오퍼랜드                |
| 수행      | 연산대상             | 연산대상                |

- 오퍼랜드로 연산코드를 수행해라
- 오퍼랜드(operand) - 명령어를 수행할 대상(피연산자)

<aside>
📌 대상(데이터)이 직접 명시되기도 하고,  **대상의 위치**가 명시되기도 한다.

</aside>

- 연산코드 (op-code) - 오퍼핸드로 수행할 동작
- 오퍼랜드의 개수는 유동적일 수 있다.
- 오퍼랜드의 개수에 따라 명령어의 개수가 달라질 수 있다.

<aside>
📌 대상의 위치 - 레지스터 이름, 메모리 주소

</aside>

### 연산코드

cpu나 메모리에 따라 다 다르지만 **대표적으로 사용하는 코드**

![command](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/cs/command/command-1.webp)

![command](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/cs/command/command-2.webp)

- 연산자
- INCREMENT - 변수 관련 증가 코드
- 조건문 연산자
- 조건문에서 두개의 대상비교

![command](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/cs/command/command-3.webp)

- JUMP - 메모리 주소를 넘겨서 대상 메모리로 가서 실행해라
- CONDITIONAL/JUMP - 조건이 추가된 JUMP
- HART - 프로그램 끄기
- CALL - 함수 호출
- RETRUN - 함수 반환

![command](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/cs/command/command-4.webp)

특정 외부장치에 대한 연산을 제어할 때 사용하는 코드

## 주소지정

연산코드의 대상이 되는 데이터가 실제로 메모리나 레지스터에 저장되어 있을 때 어떻게 찾아가는지에 대해 알아보자

- 유효 주소를 찾는 방법
- CPU 마다 차이가 있다.

### 데이터를 직접 명시하지 않고 위치를 명시하는 이유

why?

명령어의 길이가 한정되어 있기 때문이다.

**오퍼랜드(명령어)가 들어갈 수 있는 길이는 한정되어 있기 때문에 대부분 메모리상 주소나 레지스터 이름을 지정해 사용한다.**

<aside>
📌 유효주소 - 연산코드에 사용할 데이터가 저장된 위치, 즉 연산의 대상이 되는 데이터가 저장된 위치

</aside>

### 즉시 주소 지정

- 연산에 사용할 데이터를 **오퍼랜드 필드에 직접 명시**
- 가장 빠른 주소 지정 + 데이터 크기에 제한

### 직접 주소 지정

- 오퍼랜드 필드에 유효 주소(연산에 사용될 데이터가 저장된 메모리 주소) 명시
- 오퍼랜드 필드로 표현 가능한 메모리 주소 크기에 제한

<aside>
📌 **CPU가 레지스터에 접근하는 것보다 메모리에 접근하는 속도가 훨씬 더 느리다**

</aside>

### 간접 주소 지정

- 오퍼랜드 필드에 유효 주소의 주소 명시
- 유효 주소 크기에 제한은 없으나, 속도가 비교적 느림**(CPU에서 메모리에 두 번 접근 해야하기 때문)**

### 레지스터 주소 지정

- 연산에 사용할 데이처를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
- **레지스터 접근은 메모리보다 빠르다.**

### 레지스터 간접 주소 지정

- 연산에 사용할 데이터를 메모리에 저장하고,
- 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시
- 메모리 접근은 한 번

출처: 패스트캠퍼스
