---
title: 실행 컨텍스트 동작 원리
description: 실행 컨텍스트는 어떻게 동작할까???
date: 2024-05-08
tags: [context, javascript, mordern]
series: Mordern
published: true
---

![실행 컨텍스트 동작원리 썸네일](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP.webp)

# 1. 실행 컨텍스트의 생성과 식별자 검색과정

---

예제를 통해 실행 컨텍스트에서 어떤 식으로 코드를 동작시키는지 알아보겠다.

```jsx
function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }
  bar(10);
}
foo(20); // 42
```

## 1.1 전역 코드가 평가되기 전에 우선 전역 객체가 생성된다.

---

이때 전역 객체는 `빌트인 전역 프로퍼티`와 `빌트인 전역 함수` 그리고 `표준 빌트인 객체`가 추가 되면 동작 환경에 따라 클라이언트 사이드 **WEB API(DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등)**또는 특정 환경을 위한 호스트 객체를 포함한다.

> 즉, 전역객체도 프로토타입 체인의 일원이다.

## 1.2 전역 코드 평가

---

소스코드가 로드되면 자바스크립트 엔진은 전역 코드를 평가한다.

![실행 컨텍스트 동작원리 이미지 1](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP1.webp)

평가 과정은 다음과 같다.

1. **실행 컨텍스트** 생성
2. **전역 렉시컬 환경** 생성

   2.1 **전역 환경 레코드** 생성

   2.1.1 **객체 환경 레코드** 생성

   2.1.2 **선언적 환경 레코드** 생성

   2.2 **this 바인딩**

   2.3 **외부 렉시컬 환경**에 대한 참조 결정

하나 씩 알아보도록 하겠다.

### 1.2.1 전역 실행 컨텍스트 생성

비어있는 전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시한다. 이때 **전역 실행 컨텍스트는 최상위 컨텍스트를 의미한다.**

![실행 컨텍스트 동작원리 이미지 2](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP2.webp)

### 1.2.2 전역 렉시컬 환경 생성

`전역 렉시컬 환경`을 **생성하고** `전역 실행 컨텍스트`에 **바인딩** 한다.

![실행 컨텍스트 동작원리 이미지 3](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP3.webp)

`렉시컬 환경`은 `환경 레코드`와 `외부 렉시컬 환경에 대한 참조` 인 두 개의 컴포넌트로 구성된다고 했다.

- 전역 환경 레코드 생성

  전역 변수를 관리하는`전역 스코프`, `전역 객체의 빌트인 전역 프로퍼티`, `전역 함수`, `표준 빌트인 객체`를 제공한다.

  **전역 환경 레코드**는 `객체환경 레코드`와 `선언적 환경 레코드`로 구성되어있다.

  - 객체 환경 레코드 생성

    ![실행 컨텍스트 동작원리 이미지 4](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP4.webp)

    **전역 코드 평가 과정**에서 **var 키워드**로 선언한 **전역 변수**와 **함수 선언문**으로 정의된 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된 `BindingObject`를 통해 **전역 객체**의 `프로퍼티`와 `메서드`가 된다.

  - 선언적 환경 레코드 생성

    ![실행 컨텍스트 동작원리 이미지 5](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP5.webp)

    var 키워드로 선언된 전역 변수와 함수 선언문으로 정의한 전역 함수 이외의 선언, 즉 \***\*`let`, `const` **키워드로 선언한 전역 변수는 선언적 환경 레코드에 등록되고 관리된다.\*\*

    이는 따로 관리되기 때문에 `window.y` 와 같이 **전역 객체의 프로퍼티**로서 참조 할 수 없다.

    또한 `const` 키워드로 선언한 변수는 `선언 단계`와 `초기화 단계`가 분리되어 진행한다.

    즉, **런타임에 실행 흐름이 변수 선언문에 도달하기 전까지** `일시적 사각지대(Temporal Dead Zone)`**에 빠지게 된다.**

    **호이스팅이 발생하지만 런타임에 컨트롤이 변수 선언문에 도달하기 전까지는 참조 할 수 없다.**

### 1.2.3 this 바인딩

![실행 컨텍스트 동작원리 이미지 6](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP6.webp)

전역 환경 레코드의`[[GlobalThisValue]]` 내부 슬롯에 `this`가 바인딩된다.

일반적으로 전역 코드에 `this`는 전역 객체를 가리킨다. 따라서 전역 환경 레코드의 전역 환경 레코드의 `[[GlobalThisValue]]`내부 슬롯에 바인딩 되어있는 객체가 반환된다.

전역 코드에서 `this`를 참조하면 전역 환경 레코드의 `[[GlobalThisValue]]`내부 슬롯에 바인딩 되어있는 객체가 반환된다.

- 외부 렉시컬 환경에 대한 참조 결정

  외부 렉시컬 환경에 대한 참조는 현재 평가 중인 소스코드를 포함하는 외부 소스코드의 렉시컬 환경, 즉 상위 스코프를 가리키고 단방향 링크드 리스트인 스코프 체인을 구현한다.

  외부에 참조하는 스코프가 존재하지 않다면 `null` 값으로 존재한다.

  ![실행 컨텍스트 동작원리 이미지 7](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP7.webp)

## 1.3 전역 코드 실행

---

렉시컬 환경에 대한 구성을 마치고 전역코드가 순차적으로 실행되기 시작한다.

변수 할당문이 실행되어 x, y에 값이 할당 된다. 함수가 호출된다. 이때 변수 할당문 또는 함수 호출문을 실행하기 위해 선언된 식별자 인지 확인하고 스코프가 다른 식별자는 동일한 이름을 가질 수 있다. 따라서 어느 스코프에 어떤 식별자인지 결정하는 것을 **식별자 결정**이라 한다.

**식별자 결정을 위해 식별자를 검색할때 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작한다.**

식별자들은 렉시컬 환경의 환경 레코드에 저장되어 있고 실행 중인 실행 컨텍스트에 식별자가 존재하지 않는다면 외부 렉시컬 환경 참조 값으로 이동해 상위 스코프로 이동해 찾는다. 전역 렉시컬 환경에서도 찾지 못하면 참조 에러(ReferenceError)를 일으킨다.

**실행 컨텍스트는 소스코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.**

## 1.4 함수 코드 평가

---

함수 코드 평가는 아래 순서와 같다.

- 함수 실행 컨텍스트 생성
- 함수 렉시컬 환경 생성
  - 함수 환경 레코드 생성
  - this 바인딩
  - 외부 렉시컬 환경에 대한 참조 결정

순서로 이루어진다.

# 2. 실행 컨텍스트와 블록 레벨 스코프

---

`var` 키워드로 선언한 변수는 오로지 함수의 코드 블록만 지역 스코프로 인정하는 `함수 레벨 스코프`를 따른다. 하지만 `let`, `const` 키워드로 선언한 변수는 모든 코드 블록을 지역 스코프로 인정하는 `블록 레벨 스코프`를 따른다.

```jsx
let x = 1;
if (true) {
  let x = 10;
  console.log(x); // 10
}
console.log(x); // 1
```

if 문의 코드 블록 내에서 let 키워드 변수가 선언 되었다. 따라서 if 문 코드 블록이 실행되면 if 문의 코드 블록을 윟ㄴ 블록 레벨 스코프를 생성해야 한다. 이를 위해 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성해 기본 전역 렉시컬 환경을 교체 해야한다.

이때 새롭게 생성된 if 문의 코드 블록을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 if 문이 실행되기 이전의 전역 렉시컬 환경을 가리킨다.

![실행 컨텍스트 동작원리 이미지 8](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP8.webp)

if 문 코드 블록의 실행이 종료되면 if 문의 코드 블록이 실행 되기 이전의 렉시컬 환경으로 되돌린다.

![실행 컨텍스트 동작원리 이미지 9](https://raw.githubusercontent.com/thdtjdgml415/next-blog/main/assets/img/context-OP9.webp)

이는 블록 레벨 스코프를 생성하는 모든 블록문에 적용된다.

# 결론

---

자바스크립트의 동작원리를 이해하기 위해서는 실행 컨텍스트의 동작원리를 아는 것은 너무나 중요한 일이다. 이번에 책을 읽고 여러 자료를 찾아보며 머리 속으로 계속 생각해봤지만 다른 이벤트 핸들러나 클로저, 프로토타입 체인 같은 다른 개념들과 합쳐지면 복잡해 지는 것 같다.

이과정들을 머릿속으로 단순화 시키고 원하는 코드의 동작원리에 대해 핵심을 뽑아서 생각해보고 파악해보는 능력은 계속 코드를 쳐보고 생각하는 훈련이 필요한 것 같다.

전에 코드를 칠때는 대략 생각해보고 어떻게 돌아가겠다 가볍게 생각하고 `console.log`를 사용하여 메서드를 파악했다면
이제는 깊게 코드가 어떻게 렉시컬 환경을 구성하고 외부 코드와 어떻게 상호작용하는지?, 스택은 어떻게 쌓여서 동작하는지? 생각해보고 코드를 읽어나갈 수 있는 바탕을 얻는 시간이였다.
